section 2.3.4 page 18

性能调整发生在越靠近工作执行的地方效果最显著。

| 层级     | 调优对象                                       |
| -------- | ---------------------------------------------- |
| 应用程序 | 执行的数据库请求                               |
| 数据库   | 数据库表布局、索引、缓冲                       |
| 系统调用 | 内存映射、读写、同步或异步I/O标志              |
| 文件系统 | 记录尺寸（块大小）、缓存尺寸、文件系统可调参数 |
| 存储     | RAID级别、磁盘类型和数目、存储可调参数         |



section 2.3.8 page 21

扩展性

	在一定阶段，可以观察到扩展性是线性变化的。随着到达某一点，用虚线标记，此处对于资源的争夺开始影响性能。这一点可以认为是拐点，作为两条曲线的分界。过了这一点之后，吞吐量曲线随着资源争夺加剧偏离了线性扩展，内聚性导致完成的工作变少而且吞吐量也见减小了。 这个情况可能发生在组件达到100%使用率的时候-饱和点，也可能发生在组件接近100%的使用率的时候，这时排队频繁且比较明显。

section 2.3.18 page 26

剖析(profileing) 本意指对目标对象绘图以用于研究和理解。在计算机性能领域，profiling 通常是按照特定的时间间隔对系统的状态进行采样，然后对这些样本进行研究。



section 2.4 page 28

性能分析有两个常用的视角，每个视角的受众、指标以及方法都不一样。这两个视角是工作负载和资源分析，可以分别对应理解为对系统软件栈自上而下和自底而上的分析。

	资源分析：资源分析仪对系统资源的分析为起点，涉及的系统资源有：CPU、内存、磁盘、网卡、总线以及之间的互联。

​	工作负载分析：输入-输出-latency



Section 2.5.9 page 36

USE (utilization, saturation, errors) 方法. 对于所有的资源，查看它的使用率、饱和度和错误。术语定义如下：

- 资源：所有服务器物理元器件（CPU、总线）
- 使用率：在规定时间间隔内，资源用于服务工作的时间百分比。虽然资源繁忙，但是资源还有能力接受更多的工作，不能接受更多工作的程度被视为饱和度
- 饱和度：资源不能再服务更多额外工作的程度，通常有等待队列。
- 错误：错误事件的个数。

USE 流程图如下，错误被置于检查首位，要先于使用率饱和度，错误通常容易很快被解释，在研究其它指标之前，把它梳理清楚是省时高效的。

![](C:\Users\fxp\Documents\GitHub\readings_notes\USE_flow.jpg)



section 4.2.1 page 105

top 命令会打开 /proc 进程ID名目录下一个叫 stat 的文件，然后读取该文件的内容。

top 对系统里所有活跃的进程都会重复这一操作，在某些系统中，尤其是有很多进程的系统，这些操作的执行开销会变得很明显，特别是top, 每次屏幕更新时，都对每个进程重复这样的操作，这可能会导致 top 显示自己就是 CPU 最高的消耗者。



section 7.4.2 

有可能需要检查虚拟内存的使用率，这取决于系统是否支持过度提交。对于那些不支持过度提交的系统，一旦虚拟内存耗尽，内存分配就会失败--这是一种典型的内存错误。

section 8 page 281

文件系统通过缓存、缓冲、以及异步IO等手段来缓和磁盘的延时对应用程序的影响。

读操作从缓存返回（缓存命中）或者从磁盘返回（缓存未命中）。未命中的操作被存储在缓冲中，并填充缓存（热身）。



文件系统用缓存（caching）提高读性能，而用缓冲（buffering）（在缓存中）提高西写性能。

secion 8.3.4 page 286

预取

预取是文件系统解决缓存命中率偏低，系统性能较差这个问题的通常做法，通过检查当前和上一个IO的文件偏移量，可以检测出当前是否是顺序读负载，并且做出预测，在应用程序请求前向磁盘发出读命令，以填充文件系统缓存，这样如果应用程序真的发出了读请求，就会命中缓存。 预取的预测一旦准确，应用程序的读性能将会有显著的提升。

预读

linux 重新设计了一个系统调用 readahead



写回缓存

写回缓存广泛的应用于文件系统，用来提高写性能，它的原理是，当数据写入主存后，就认为写入已经结束并返回，之后再异步地把数据输入磁盘。

为了平衡系统对于速度和可靠性的需求，文件系统默认采用写回缓存策略，但同时也提供了一个同步写的选项绕过这个机制，把数据直接写在磁盘上。

同步写

1. 单次同步写
2. 同步提交已写内容



内存文件映射

对于某些应用程序和负载，可以通过把文件映射到进程地址空间，并直接存取内存地址的方法来提高文件系统IO性能，这样可以避免调用read() 和 write() 存取文件数据时产生的系统调用和上下文切换开销。



举例应用程序写入一个字节的背后

1. 一个应用程序对一个已有的 文件发起了一个一字节的写操作
2. 文件系统定位了这个地址对应的128KB数据块，发现它未在缓存中（尽管指向数据块的元数据被缓存了）
3. 文件系统请求从磁盘载入那个记录块
4. 磁盘设备层把128KB字节的读请求分拆成适配设备的较小读请求
5. 磁盘执行了多次较小的读请求，总共１２８KB
6. 文件系统把要写入的那个字节替换成新的数据
7. 一段时间后，文件系统请求把１２８KB的“脏”记录写回到磁盘
8. 磁盘写入１２８ＫＢ的记录
9. 文件系统写入新的元数据，比如应用或者访问时间
10. 。。。

访问时间戳

许多文件系统支持访问时间戳，可以记录下每个文件和目录被访问（读取）的时间，这会造成读取文件时需要更新元数据，读取变成了消耗磁盘ＩＯ资源的写负载。有些文件系统对访问时间戳做了优化，合并及推迟这些写操作，以减少有效负载的干扰。

容量

​	当文件系统装满时，性能会因为数个原因有所下降，当写入新数据时，需要花更多时间来寻找磁盘的空闲块，而寻找过程本身也消耗计算和IO资源。



page 297

页缓存缓存虚拟内存的页面，包括文件系统的页面，提升了文件和目录的性能，页缓存大小时动态的，它会不断增长消耗可用的内存，并在应用程序需要的时候释放（和页面换出一起都受swappiness的控制）

Linux的缓存主要包含 页缓存、目录项缓存、inode缓存



page 420

现在未正确配置的防火墙开始起作用：对于过去基于ICMP的网络工具攻击，防火墙管理员通常以阻塞所有ICMP包的方式应对，这会阻止有用的“不能分段”报文到达发送方，并且一旦包长度超过1500将导致网络包被静默地丢弃，为了避免这个问题，许多系统坚持使用默认的1500MTU



page 423

通过IP与本地通信是IP套接字的进程间通信技巧。另一个技巧是UNIX域套接字（UDS），它在文件系统中建立一个用于通信的文件，由于省略了TCP/IP栈的内核代码以及协议包封装的系统开销，UDS的性能会更好。



以下是TCP性能特性的总结

1. 可变窗口：允许在收到确认前在网络上发送总和小于窗口大小的多个包，以在高延时的网络中提供高吞吐量。窗口的大小由接收方通知以表面当前它愿意接收的包的数量。
2. 阻塞避免：阻止发送过多数据进而导致饱和，它会导致丢包而损害性能。
3. 缓启动：TCP阻塞控制的一部分，它会以较小的阻塞窗口开始而后按一定时间内接收到的确认（ACK）逐渐增加，如果没有收到，阻塞窗口会降低。
4. 选择性确认（SACK）：允许TCP确认非连续的包，以减少需要重传输的数量。
5. 快速重传输：TCP能基于重复收到的确认重传输被丢弃的包
6. 快速恢复：通过重设连接开始慢启动，以在检测到重复确认后恢复TCP性能。

关于TCP性能的重要内容包括三次握手、重复确认监测、阻塞控制算法、Nagle算法、延时确认、SACK 和 FACK